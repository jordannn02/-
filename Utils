import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

import inspect
from abc import ABC, abstractmethod
import networkx as nx
from typing import List

_implemented_output_realizations = ["Basic", "ClusterFinderList", "ClusterFinder", "RegionsList", "Regions",
                                    "ZonesList", "Zones", "Isolates", "AverageDistance", "AverageOpinion",
                                    "Spread", "Dispersion", "Coverage", "Graph"]

class OutputTableCreator(ABC):
    """
    This class is responsible for creating output for the output table.
    Inherit from this class and implement the create_output method to generate the desired output cell for the output table.
    If you want the output cell to have a descriptive column name, overwrite the class variable 'label'. Otherwise, 
    column names are autogenerated.
    """

    label = ""

    def __init__(self, **kwargs):
        pass

    @abstractmethod    
    def create_output(self, network: nx.Graph, **kwargs):
        """
        This method receives a NetworkX object, performs some calculation, and outputs a cell for the output table.

        :param network: A NetworkX graph object.

        :returns: 
        """
        pass


def create_output_table(network: nx.Graph, realizations=None, colnames=None,
                        agents=None, settings_dict=None, tickwise_output=None, **kwargs):
    """
    This function works as a factory method for the OutputTableCreator component.
    It calls the create_output function of a specific implementation of the OutputTableCreator and passes to it
    the kwargs dictionary.

    :param network: A NetworkX object
    :param realizations: The specific OutputTableCreator that will be used. Currently, the options are:

        * Basic: Returns the realizations Regions, Zones, Isolates, Homogeneity, AverageDistance
        * ClusterFinder: Method to find clusters based on minimal allowed distance between network neighbors as
          defined by the user in the kwargs dictionary. Default is to return the same output as the Regions realization
        * Regions: Returns the number of regions (i.e. the number of connected components in the graph after preserving
          only the links with perfect similarity)
        * RegionsList: Returns a list with the sizes of all regions (i.e. the number of agents in each connected
          component in the graph after preserving only the links with perfect similarity)
        * Zones: Returns the number of zones (i.e. the number of connected components in the graph after preserving
          only the links with dissimilarity != 1)
        * ZonesList: Returns a list with the sizes of all zones (i.e. the number of agents in each connected component
          in the graph after preserving only the links with dissimilarity != 1)
        * Isolates: Reports the number of isolates as found in the ClusterFinder method, based on minimal allowed
          distance between network network neighbors as defined by the user in the kwargs dictionary. Default is to
          return the same output as the Regions realization
        * Homogeneity: Size of the largest cluster divided by the number of agents
        * AverageDistance: Reports average distance between connected agents, based on dissimilarity calculated during
          simulation.
        * AverageOpinion: Reports average opinion (requires a list of features for which this needs to be calculated if
          number of features > 1. Pass this list in the kwargs dictionary as AverageOpinionFeatures.)
        * Spread: Reports the spread (distance between maximum and minimum opinion)
        * Dispersion: Returns the amount of dispersion defined as the average absolute deviation from the mean on a
          given feature [Bramson2016]_
        * Coverage: Report coverage for nondiscrete features, following [Bramson2016]_
        * Graph: Returns the entire NetworkX Graph

    :param agents: A list of the indices of all agents that will be considered by the output table.
    :param settings_dict: A dictionary of column names and values that will be added to the output table. Can be used
        to merge output with parameter setting values.
    :param tickwise_output: A dictionary with a list of lists with values of agents on some given feature at each tick
        during the simulation run. This function will create a column for each key in the dictionary.

    :returns: A dictionary.
    """

    # work on a copy of the network, to avoid permanently altering anything
    network = network.copy()

    if colnames is None:
        colnames = []
    if realizations is None:
        realizations = []
    if tickwise_output is None:
        tickwise_output = {}
    if settings_dict is None:
        settings_dict = {}
    if agents is None:
        agents = []

    if len(agents) > 0:
        removenodes = list(set(list(network.nodes())) - set(agents))
        for i in removenodes:
            network.remove_node(i)

    from defSim import ClusterFinder
    from defSim.tools.OutputMeasures import AverageDistanceReporter, AverageOpinionReporter, DispersionReporter, CoverageReporter
    # Initialize output dictionary by including settings for the simulation run
    output = settings_dict

    # Create default outputs (called by name)
    ## workaround to call the ClusterFinder method only once
    cluster_dissimilarity_threshold = kwargs.get('cluster_dissimilarity_threshold', 0)
    strict_zones = kwargs.get('strict_zones', False)
    if any([i in realizations for i in ["Clusters", "ClusterList", "Basic", "Isolates", "Homogeneity"]]):
        clusterlist = ClusterFinder(cluster_dissimilarity_threshold=cluster_dissimilarity_threshold, strict_zones=strict_zones).create_output(network, **kwargs)

    # Output related to clustering
    if "ClusterList" in realizations:
        output['ClusterList'] = clusterlist
    if "ClusterFinder" in realizations:
        output['Clusters'] = len(clusterlist)
    if "RegionsList" in realizations:
        output['RegionsList'] = ClusterFinder().create_output(network)
    if any([i in realizations for i in ["Regions", "Basic"]]):
        output['Regions'] = len(ClusterFinder().create_output(network))
    if "ZonesList" in realizations:
        output['ZonesList'] = ClusterFinder(strict_zones=True).create_output(network)
    if any([i in realizations for i in ["Zones", "Basic"]]):
        output['Zones'] = len(ClusterFinder(strict_zones=True).create_output(network))
    if "Isolates" in realizations:
        output['Isolates'] = clusterlist.count(1)
    if any([i in realizations for i in ["Homogeneity", "Basic"]]):
        output['Homogeneity'] = clusterlist[0] / len(network.nodes())

    # Output related to opinions and opinion distances
    if any([i in realizations for i in ["AverageDistance", "Basic"]]):
        output['AverageDistance'] = AverageDistanceReporter().create_output(network)
    if any([i in realizations for i in ["AverageOpinion", "Basic"]]):
        opinionfeatures = kwargs.get("AverageOpinionFeatures", ['f01','f02','f03'])
        for i in opinionfeatures:
            output['AverageOpinion{}'.format(i)] = AverageOpinionReporter(feature = i).create_output(network)
            ops = list(nx.get_node_attributes(network, i).values())
            for n_op in [0,1,2,99]:
                output['Opinion{}_{}'.format(i, n_op)] = np.sum(np.array(ops)==n_op)
    if "Spread" in realizations:
        opinionfeatures = kwargs.get("SpreadOpinionFeatures", ['f01'])
        for i in opinionfeatures:
            output['Spread{}'.format(i)] = SpreadReporter(feature=i).create_output(network)
    if "Dispersion" in realizations:
        opinionfeatures = kwargs.get("DispersionOpinionFeatures", ['f01'])
        for i in opinionfeatures:
            output['Dispersion{}'.format(i)] = DispersionReporter(feature=i).create_output(network)
    if "Coverage" in realizations:
        opinionfeatures = kwargs.get("CoverageOpinionFeatures", ['f01'])
        for i in opinionfeatures:
            output['Coverage{}'.format(i)] = CoverageReporter(feature=i).create_output(network)

    # Output the entire networkX Graph object
    if "Graph" in realizations:
        output['Graph'] = network

    # Create custom outputs (by calling implementations of OutputTableCreator)
    ## Select only those realizations which are classes (not instances of a class) and of those only if they are a subclass of OutputTableCreator
    custom_realizations = [realization for realization in realizations if (inspect.isclass(realization) and issubclass(realization, OutputTableCreator)) or isinstance(realization, OutputTableCreator)]
    for realization in custom_realizations:
        if realization.label != "":
            output[realization.label] = realization.create_output(network)
        else:
            output["CustomOutput{}".format(custom_realizations.index(realization))] = realization.create_output(network)

    # Add tickwise output if applicable
    if tickwise_output:
        for f in tickwise_output.keys():
            output['Tickwise_' + str(f)] = tickwise_output[f]

    if colnames != []:
        for i in colnames:
            output[i] = output.pop(realizations[colnames.index(i)])

    return output

def plot_degree_dist(G):
    degrees = [G.degree(n) for n in G.nodes()]
    plt.hist(degrees)
    plt.show()

def directed_spatial_random_graph(num_agents=1000, degree=12, proximity_weight=1, return_positions=False, seed=None):
    # print(num_agents, degree)
    np.random.seed(seed)
    
    if type(degree) == int:
        degree_seq = [degree for i in range(num_agents)]
    elif type(degree) == list:
        if len(degree) == num_agents:
            degree_seq = degree
        else:
            raise ValueError('\'degree\' is not of length \'num_agents\'')
    else:
        raise ValueError('\'degree\' should be an integer or a list with length \'num_agents\'')
    if any([i >= num_agents for i in degree_seq]):
        degree_seq = [i if i < num_agents else (num_agents-1) for i in degree_seq]

    xypos = np.column_stack((np.random.uniform(0, 100, num_agents), np.random.uniform(0, 100, num_agents)))

    def dist(posA, posB, proximity_weight):  # returns the probability as a function of distance
        return np.exp(-proximity_weight * np.sqrt(np.sum((posA - posB) ** 2)))

    distmatrix = np.zeros((num_agents, num_agents))

    for i in range(num_agents):
        for j in range(num_agents):
            if i == j:
                distmatrix[i, j] = 0  # later turned to 0!
            else:
                distmatrix[i, j] = dist(xypos[i], xypos[j],proximity_weight)

    # pick min_neighbors neighbors with a probability equal to their relative euclidean distance
    edgelist = []
    degreelist = []
    
    for i in range(num_agents):
        distp = distmatrix[i]
        distp /= distp.sum()  # normalizing the probabilities

        if degreelist.count(i) < degree_seq[i]:
            try:
                alters = np.random.choice(num_agents, degree_seq[i], replace=False, p=distp)
                for j in alters:
                    edgelist.append([i, j])
                    degreelist.append(i)
                    #degreelist.append(j)
            except(ValueError):
                print(
                    "Please pick a lower value for the proximity weight. This value creates too many probability values of 0")

    G = nx.DiGraph()
    G.add_nodes_from([i for i in range(num_agents)])
    G.add_edges_from(edgelist)
    
    if return_positions:
        return G, xypos
    else:
        return G


def get_node_ids_percentile(network, type='all'):
    degs = [val for (node, val) in network.degree()]
    loner_deg, kol_deg = np.quantile(sorted(degs), q=(0.1,0.9))
    N = len(degs)
    if type=='all':
        return np.random.randint(0, N)
    if type=='longer':
        candidate = [node for (node, val) in network.degree() if val < loner_deg]
    else:
        candidate = [node for (node, val) in network.degree() if val > kol_deg]
    
    #return np.random.choice(candidate)
    return 

def get_node_ids(network, type='all'):
    node_deg = {node: val for (node, val) in network.degree()}
    sorted_nodes = [k for k, v in sorted(node_deg.items(), key=lambda item: item[1])]
    N = len(network.degree())
    if type=='all':
        candidate = sorted_nodes[:25] + sorted_nodes[-25:]
    elif type=='loner':
        candidate = sorted_nodes[:25]
    elif  type=='kol':
        candidate = sorted_nodes[-25:]
    else:
        raise ValueError('type not supported')
    #return np.random.choice(candidate)
    return candidate
  
def set_nodes(network, node_ids, values = {'f01':1, 'f02':1, 'f03':99}):
    for node_id in node_ids:
        for key in  network.nodes[node_id].keys():
            network.nodes[node_id][key] = values[key]

def get_net_info(network):
    #plot_degree_dist(G_poisson)
    info = {
        "average_clustering": nx.average_clustering (network , nodes = None , weight = None , count_zeros = True),
        "transitivity": nx.transitivity(network),
        "density": nx.density(network),
        "average_shortest_path_length": nx.average_shortest_path_length(network),
    }

    return info

if __name__ == "__main__":
    N = 1000
    G_poisson = directed_spatial_random_graph(num_agents=N, degree=[round(i) for i in (np.random.poisson(K,N) * np.random.poisson(K,N)) / K],
                                         return_positions = False) 
    make_summary()
